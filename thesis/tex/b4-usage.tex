\chapter{Примеры использования и перспективы}

\section{Получение числа π методом Гальперина}\label{pipool}

Реализованную симуляцию можно использовать для вычисления числа \(\pi\)
методом Г.~Гальперина~\cite{poolpi}.
Этот метод заключается в том, что в системе из стенки слева,
тела массой \(1\) и телом массой \(100^{n - 1}\) эти тела соударяются и число этих столкновений
будет равно первым \(n\) цифрам числа~\(\pi\)~\cite{habrpi}.
При этом, в системе нет трения, т.е. сталкиваться тела закончат, когда оба улетят вправо, причём у тела с меньшей массой скорость будет меньше.
Разработанный движок хоть и рассчитан на движение с трением, но может и без него, если коэффициент трения сделать равным нулю.

Например, рассчитать первые 4 цифры можно следующим образом.
Очистить модель, поставить воспроизведение на паузу и отмотать время в ноль~(рисунок~\ref{pistep1fig}).

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep1}
    \caption{Шаг 1\label{pistep1fig}}
\end{figure}

Добавить вертикальную линию, которая будет располагаться слева от тел~(рисунок~\ref{pistep2fig}).

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep2}
    \caption{Шаг 2\label{pistep2fig}}
\end{figure}

Добавить тело с меньшей массой~(рисунок~\ref{pistep3fig}).
Так как оно должно быть правее добавленной линии, координата по оси \(X\)
добавляемого тела должна быть больше.

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep3}
    \caption{Шаг 3\label{pistep3fig}}
\end{figure}

Добавить тело с большей массой, его координата по оси \(X\) должна быть ещё больше;
радиус можно оставить таким же, а масса должна быть в \(100^3\) раз больше так как требуется вычислить 4 цифры;
скорость этого тела должна быть направлена влево (рисунок~\ref{pistep4fig}).

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep4}
    \caption{Шаг 4\label{pistep4fig}}
\end{figure}

Убрать галочки, отвечающие за параметры расчёта, чтобы модель рассчиталась до конца~(рисунок~\ref{pistep5fig}).

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep5}
    \caption{Шаг 5\label{pistep5fig}}
\end{figure}

Снять воспроизведение с паузы и дождаться когда произойдёт расчёт. Можно наблюдать за столкновениями,
или сразу открыть статистику и в счётчике столкновений будет искомое число: \(3141\), что является
первыми 4 цифрами числа \(\pi \approx 3.14159265359\).

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{pistep6}
    \caption{Шаг 6\label{pistep6fig}}
\end{figure}

\section{Визуализация броуновского движения}

Броуновское движение~-- хаотическое перемещение очень малых частиц вещества под действием ударов молекул~\cite{browniankrugosvet}.
Столкновения молекул можно визуализировать реализованным движком.
Однако, асимптотическая сложность реализованного алгоритма равна~(\ref{onmk}), так как требуется перебирать все пары тело-тело, тело-линия, тело-точка.

\begin{equation}\label{onmk}
    O(n(n + m + k))
\end{equation}

\begin{Underequation}
    \(n\)~-- количество тел;

    \(m\)~-- количество линий;

    \(k\)~-- количество точек.
\end{Underequation}

Поэтому, когда в модели слишком много объектов, вычисления идут намного медленнее, а для визуализации броуновского движения желательно использовать много тел (частиц).
Это можно можно будет смягчить, оптимизировав алгоритм. Возможные оптимизации рассмотрены далее в пункте~\ref{optimization}.
Но всё равно на рисунке~\ref{brownianfig} представлена раскадровка с шагом в \(0.1\) секунду визуализации условного броуновского движения с 15 частицами.

\begin{figure}[H]
    \centering
    \includegraphics[width=16cm]{brownian}
    \caption{Раскадровка примера визуализации броуновского движения\label{brownianfig}}
\end{figure}

\section{Перспективы и дальнейшее возможное развитие}

\subsection{Расширение возможностей многопользовательского режима}

\TODO Сохранение реплеев на сервере, чат.

\subsection{Клон игры <<Смешарики>> (может быть известна как <<Чапаев>>)}

\TODO https://shararam.fandom.com/wiki/Смешарики\_(игра)

\subsection{Оптимизация}\label{optimization}

Из-за ограниченного времени, при реализации алгоритма не было приоритета сделать его оптимальным.
Поэтому многие места реализованы тривиально, что могло привести к лишним вычислениям, что плохо отразилось на производительности.
Например, во многих местах, где требуется перебирать пары,
можно не перебирать пары одинаковых элементов и пары, которые уже были учтены, но с другим порядком элементов.
При использовании символьных вычислений, вывод выражения вычисляется каждый раз заново, несмотря на то, что выражения используются каждый раз одни и те же.
Это можно оптимизировать, сохраняя результат, т.е. использовать мемоизацию.
Далее, для поиска узких мест алгоритма можно использовать профилирование и пытаться оптимизировать их.

Другой подход увеличения производительности~-- использовать не одно процессорное ядро, а несколько, т.е. использовать параллелизм.
Хоть и в пункте~\ref{concurrent12} указано, что OCaml является языком с однопоточной средой выполнения,
готовится релиз OCaml 5.0 (Multicore OCaml)~\cite{infoqmulticore}, в котором будет поддержана многопоточная среда выполнения.
А это значит, что многие места реализованного алгоритма можно будет распараллелить.
Например, используя пул доменов (потоков) библиотеки domainslib~\cite{domainslibgithub},
можно вычислять одновременно такие вычисления как обнаружение столкновений, или даже поиск корней уравнения.
В JavaScript среде выполнения параллелизм не поддерживается, поэтому придётся написать абстракцию пула доменов,
которая для клиентской (браузерной) среды выполнения будет использовать 1 поток, а для серверной несколько потоков.

\subsection{Обобщение \TODO}

\TODO Воздействие нескольких сил, неупругие столкновения,
применение действий при взаимодействии или даже трёхмерное пространство и т.д.

% \subsection{Формальная верификация частей алгоритма}

\TODO
