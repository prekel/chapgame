\chapter{Теоретические сведения}\label{chapter-theory}

\section{Определения}

Физический движок~-- программное обеспечение, предназначенное для приближённой симуляции физический
систем реального мира в виртуальном, например динамику твёрдого тела
(включая обнаружение столкновений и обработку ударов).

Иными словами, система физического моделирования
(т.е. моделирующая физику -- в данном контексте симуляция синонимична моделированию)
и есть физический движок.

Традиционно, физические движки делятся на 2 типа: игровые и научные.
Отличительная черта первых --
возможность работы в режиме реального времени, то есть воспроизводить физические процессы в игре
с той же самой скоростью, в которой они происходят в реальном мире.
Отличительная черта вторых -- важна точность вычислений, скорость вычислений не играет существенной роли.

Кроме того, в игровых движках зачастую достаточно симулировать только текущее состояние виртуального мира без сохранения результата,
а в научных движках необходимо сохранять все смоделированные в виртуальном мире взаимодействия для последующего анализа.

Одна из задач данной работы~-- создать движок, имеющий свойства и научного, и игрового~--
чтобы присутствовала возможность и моделирования в реальном времени, и эффективной <<перемотки>>.

\section{Апостериорный и априорный подход}

В философском смысле, апостериори означает знание, полученное из опыта;
а априори означает знание, полученное до опыта и независимо от него~\cite[с.~105-106]{kant}.

В аналогичном порядке и делят подходы к реализации физических моделей:
определение столкновения апостериори и
априорный подход (обнаружение до происхождения столкновения).

В апостериорном случае физическое моделирование продвигается на небольшой шаг, а затем проверяется,
пересекаются ли какие-либо объекты или, по видимости, считаются пересекающимися. На каждом шаге
моделирования создается список всех пересекающихся тел, а положения и траектории этих объектов <<фиксируются>>
для учета столкновения. Этот метод называется апостериорным, поскольку он, как правило, не учитывает фактический
момент столкновения, а фиксирует столкновение только после того, как оно произошло.

В априорных методах существует алгоритм обнаружения столкновений, который сможет очень точно предсказать
траектории физических тел. Моменты столкновения рассчитываются с высокой точностью, при этом физические тела
никогда фактически не пересекаются. Это называется априорным, потому что алгоритм обнаружения столкновений
вычисляет моменты столкновения до того, как он обновит конфигурацию физических тел.

Основные преимущества апостериорных методов заключаются в том, алгоритму обнаружения
столкновений не нужно знать о множестве физических переменных; алгоритму подается простой список физических тел,
и программа возвращает список пересекающихся тел. Алгоритму обнаружения столкновений не нужно понимать трение,
упругие столкновения или, что еще хуже, неупругие столкновения и деформируемые тела. Кроме того, апостериорные
алгоритмы в действительности на одно измерение проще, чем априорные алгоритмы. Априорный алгоритм должен иметь дело
с переменной времени, которая отсутствует в апостериорной задаче.

С другой стороны, у апостериорных алгоритмы существует шаг <<исправления>>, где пересечения
(которые физически не являются правильными) должны быть исправлены и это может создать проблему.
Более того, если дискретный шаг слишком велик, столкновение может остаться незамеченным,
в результате чего объект пройдет сквозь другой, если он достаточно быстрый или маленький.

Преимуществами априорных алгоритмов являются повышенная точность и стабильность. Физическое моделирование
трудно отделить от алгоритма обнаружения столкновений. Однако во всех случаях, кроме самых простых,
проблема определения времени когда два тела столкнутся заранее (учитывая некоторые начальные данные),
не имеет аналитического решения -- обычно требуется численный поиск корней (что и описано в~\ref{solvefourthdegree}).

Обычно для игровых физических движков используется апостериорный подход потому что не важна точность,
а дискретное моделирование хорошо ложиться на расчёты в реальном времени.
Однако данная работа призвана исследовать априорный подход и при этом создать движок, способный на симуляцию в реальном времени.

Как указано ранее, априорный подход должен учитывать моделируемые законы физики. Но при этом много что трудно учесть, поэтому
симулируемая модель будет упрощённая, без учёта деформации, вращения, формы. Подвижные объекты~-- только тела идеально круглой формы,
движение равноускоренное (равнозамедленное, но в дальнейшем везде называется равноускоренным),
и т.д. Подробнее модель описана под пунктом~\ref{model_1_3}.

\section{Описание модели}\label{model_1_3}

\textbf{Тело}. Абсолютно твёрдое тело в форме круга равномерной плотности
(центр масс в центре круга) обладающее массой (\(m\)), коэффициентом трения (\(\mu\)),
радиусом (\(r\)), начальной скоростью (\(\vec{v_0}\)), положением (координаты \(x\) и \(y\) или радиус-вектор \(\vec{r}\)).
На тело действует сила трения (\(F_\text{тр.}\)).

\textbf{Точка}. Неподвижная точка в пространстве, определена через координаты.

\textbf{Линия}. Неподвижная прямая линия в пространстве, может быть ограничена точкой с двух или
одной сторон образуя отрезок или луч соответственно. Определена через общее уравнение прямой~(\ref{straight-equation}).

\begin{equation}\label{straight-equation}
  Ax + By + C = 0
\end{equation}

\begin{Underequation}
  \(A\),~\(B\),~\(C\)~-- коэффициенты общего уравнения прямой.
\end{Underequation}

\textbf{Сцена}. Множество тел, линий, точек и постоянных (например, ускорение свободного падения).

Обновлённая сцена~-- сцена, в которой обновлены параметры тел, линий, точек или постоянных.

Сцена через время \(\Delta t\)~-- обновлённая сцена, в которой все тела обновлены так,
что новая начальная скорость равна скорости в этот момент времени~(\ref{v_new_old}).

\begin{equation}\label{v_new_old}
  \vec{{v_0}_\text{new}} = \vec{v}(\Delta t)
\end{equation}

\begin{Underequation}
  \(\vec{{v_0}_\text{new}}\)~-- новая начальная скорость;

  \(\vec{v}(\Delta t)\)~-- старая скорость в момент времени \(\Delta t\).
\end{Underequation}

\textbf{Модель}. Множество пар \((t, S)\), где \(t\)~-- момент времени, а \(S\)~-- сцена.
Иными словами, модель представляет собой цепочку сцен, для каждой из которой указан момент времени.

Сцена в момент времени \(t_1\)~-- такая сцена \(S_0\) через время \(t_1 - t_0\),
где пара \((t_0, S_0)\) является членом модели, при этом соблюдается~(\ref{forall_1}).

\begin{equation}\label{forall_1}
  \forall (t, S) \in M~~(t \leqslant  t_0 \vee t > t_1)
\end{equation}

\begin{Underequation}
  \(M\)~-- модель;

  \(t_0\)~-- время, выбранное для получения модели в момент времени \(t_1\);
\end{Underequation}

Иными словами, для того чтобы получить сцену в момент времени, надо из цепочки сцен найти такую,
у которой время будет максимально, но при этом меньше требуемого момента времени и получить
сцену через разность требуемого и найденного времени по формуле~(\ref{v_new_old}).

\textbf{Столкновение}. Так как тела не могут пересекаться, и при этом передвигаются, могут происходить столкновения.
Так же тела не могут пересекаться с точками и линиями. Т.е. тела могут сталкиваться с телами, или линиями, или точками.
Уравнение столкновения тела с телом~(\ref{bodybodycollision})-через радиус-вектор,~(\ref{bodybodycollisioncoords})-через координаты.

\begin{equation}\label{bodybodycollision}
  \left|\vec{r_1}(t) - \vec{r_2}(t)\right| = r_1 + r_2
\end{equation}

\begin{Underequation}
  \(\vec{r_1}(t)\)~-- радиус-вектор положения первого тела;

  \(\vec{r_2}(t)\)~-- радиус-вектор положения второго тела;

  \(r_1\)~-- радиус первого тела;

  \(r_2\)~-- радиус второго тела.
\end{Underequation}

\begin{equation}\label{bodybodycollisioncoords}
  \sqrt{(x_1(t) - x_2(t))^2 + (y_1(t) - y_2(t))^2} = r_1 + r_2
\end{equation}

\begin{Underequation}
  \(x_1(t)\)~-- координата положения первого тела по оси \(X\);

  \(y_1(t)\)~-- координата положения первого тела по оси \(Y\);

  \(x_2(t)\)~-- координата положения второго тела по оси \(X\);

  \(y_2(t)\)~-- координата положения второго тела по оси \(Y\).
\end{Underequation}

Эти уравнения получены исходя из того что разность векторов является вектором из центра одного тела в центр другого~\cite[с.~39]{mathforprogrammers}.
И тогда, если его длина равна сумме радиусов этих тел, значит тела столкнулись.

Подобным образом можно определить уравнение столкновения тела с точкой:
(\ref{bodypointcollision})-через радиус-вектор,~(\ref{bodypointcollisioncoords})-через координаты.

\begin{equation}\label{bodypointcollision}
  \left|\vec{r}(t) - \vec{p}\right| = r
\end{equation}
\begin{Underequation}
  \(\vec{r}(t)\)~-- радиус-вектор положения тела;

  \(\vec{p}\)~-- радиус-вектор точки;

  \(r\)~-- радиус тела.
\end{Underequation}

\begin{equation}\label{bodypointcollisioncoords}
  \sqrt{(x(t) - p_x)^2 + (y(t) - p_y)^2} = r
\end{equation}

\begin{Underequation}
  \(x(t)\)~-- координата положения тела по оси \(X\);

  \(y(t)\)~-- координата положения тела по оси \(Y\);

  \(p_x\)~-- координата точки по оси \(X\);

  \(p_y\)~-- координата точки по оси \(Y\).
\end{Underequation}

С обнаружение столкновением тела и линии ситуация несколько иная,
надо воспользоваться формулой расстояний от точки до прямой~(\ref{distance_1})~\cite[с.~452]{larson}
и тогда получится~(\ref{bodylinecolision}).

\begin{equation}\label{distance_1}
  \frac{\left|Ax + By + C\right|}{\sqrt{A^2 + B^2}}
\end{equation}

\begin{Underequation}
  \(x\),~\(y\)~-- координаты точки.
\end{Underequation}

\begin{equation}\label{bodylinecolision}
  \frac{\left|A x(t) + B y(t) + C\right|}{\sqrt{A^2 + B^2}} = r
\end{equation}

\begin{Underequation}
  \(x(t)\),~\(y(t)\)~-- координаты тела в момент времени \(t\).
\end{Underequation}

В дальнейшем будут определены формулы для нахождения положения тела, а именно:~(\ref{r_x_1}),~(\ref{r_y_1}).

\section{Определение формул скорости и траектории тела}

Далее, под моментом времени \(t\) будет подразумеваться время относительно сцены, а не модели.

Как указано выше, у тела есть начальная скорость и на него действует сила трения.
По второму закону Ньютона~\cite[с.~114]{rowellherbert}, у тела есть ускорение так как на него действует сила.
Такое движение называется равноускоренным.

Скорость при равноускоренном движении определяется формулой~(\ref{velocityvec_1})~\cite[с.~96]{rowellherbert}.

\begin{equation}\label{velocityvec_1}
  \vec{v}(t) = \vec{v_0} + \vec{a}t
\end{equation}

\begin{Underequation}
  \(\vec{v}(t)\)~-- вектор скорости тела в момент времени \(t\);

  \(\vec{v_0}\)~-- вектор начальной скорости тела;

  \(\vec{a}\)~-- вектор ускорения тела;

  \(t\)~-- момент времени.
\end{Underequation}

При этом вектор ускорения сонаправлен вектору силы (по второму закону Ньютона,~(\ref{newton_law_2})).

\begin{equation}\label{newton_law_2}
  \vec{a} = \frac{\vec{F}}{m}
\end{equation}

\begin{Underequation}
  \(\vec{a}\)~-- вектор ускорения тела;

  \(\vec{F}\)~-- вектор силы действующей на тело;

  \(m\)~-- масса тела.
\end{Underequation}

Но вектор силы трения \(\vec{F_{\text{тр.}}}\) противонаправлен вектору скорости тела~\cite[с.~21]{rowellherbert}.
Поэтому, и вектор ускорения тела будет противонаправлен вектору скорости тела.

При этом вектор скорости тела \(\vec{v}(t)\) должен быть сонаправлен вектору \(\vec{v_0}\)
потому что тело не может поменять направление движения при воздействии силы трения.
Для того чтобы выяснить, при каких \(t\) сонаправленность векторов \(\vec{v}(t)\) и \(\vec{v_0}\)
в уравнении~(\ref{velocityvec_1}) соблюдается,
достаточно увидеть, что длина вектора \(\vec{v_0}\) должна быть больше длине вектора \(\vec{a}t\)
и получить неравенство для \(t\)~(\ref{constraint_t_1}).

% \[
%   \left|\vec{v_0}\right| > \left|\vec{a}t\right|
% \]
% \[
%   \left|\vec{v_0}\right| > \left|\vec{a}\right| t
% \]
% \[
%   \frac{\left|\vec{v_0}\right|}{\left|\vec{a}\right| } > t
% \]

\newcommand\Constraintt{
  \frac{\left|\vec{v_0}\right|}{\left|\vec{a}\right|}
}

\newcommand\Constrainttle{
  t < \Constraintt
}

\newcommand\Constrainttge{
  t \geqslant \Constraintt
}

\begin{equation}\label{constraint_t_1}
  \Constrainttle
\end{equation}

А для остальных \(t\), \(\vec{v}(t)\) следует принять нулю. Тогда скорость выражается через~(\ref{v_system}):

\begin{equation}\label{v_system}
  \vec{v}(t) =
  \begin{cases}
    \vec{v_0} + \vec{a}t, & 0 \leqslant \Constrainttle, \\
    0,                    & \Constrainttge .
  \end{cases}
\end{equation}

Проекции на ось абсцисс~(\ref{v_x_1}) и ординат~(\ref{v_y_1}):

\begin{equation}\label{v_x_1}
  v_x(t) =
  \begin{cases}
    {v_0}_x + a_x t, & 0 \leqslant \Constrainttle, \\
    0,               & \Constrainttge.
  \end{cases}
\end{equation}

\begin{Underequation}
  \(v_x(t)\)~-- проекция вектора скорости тела \(\vec{v}(t)\) в момент времени \(t\) на ось \(X\);

  \({v_0}_x\)~-- проекция вектора начальной скорости тела \(\vec{v_0}\) на ось \(X\);

  \(a_x\)~-- проекция вектора ускорения тела \(\vec{a}\) на ось \(X\).
\end{Underequation}

\begin{equation}\label{v_y_1}
  v_y(t) =
  \begin{cases}
    {v_0}_y + a_y t, & 0  \leqslant \Constrainttle, \\
    0,               & \Constrainttge.
  \end{cases}
\end{equation}

\begin{Underequation}
  \(v_y(t)\)~-- проекция вектора скорости тела \(\vec{v}(t)\) в момент времени \(t\) на ось \(Y\);

  \({v_0}_y\)~-- проекция вектора начальной скорости тела \(\vec{v_0}\) на ось \(Y\);

  \(a_y\)~-- проекция вектора ускорения тела \(\vec{a}\) на ось \(Y\).
\end{Underequation}

Теперь найдём формулу для траектории движения тела. Формуле, соответствующей~(\ref{velocityvec_1}),
только для траектории, соответствует~(\ref{traectoryvec_1}):

\begin{equation}\label{traectoryvec_1}
  \vec{r}(t) = \vec{r_0} + \vec{v_0}t + \frac{\vec{a}t^2}{2}
\end{equation}

\begin{Underequation}
  \(\vec{r}(t)\)~-- радиус-вектор положения тела в момент времени \(t\);

  \(\vec{r_0}\)~-- радиус-вектор начального положения тела.
\end{Underequation}

Исходя из~(\ref{v_system}), требуется определить положение тела после его остановки.
Для этого надо подставить время остановки \(t = \Constraintt\) в формулу~(\ref{traectoryvec_1}) и получится~(\ref{r_system_1}).

\begin{equation}\label{r_system_1}
  \vec{r}(t) = \begin{cases}
    \vec{r_0} + \vec{v_0}t + \frac{\vec{a}t^2}{2},                                                                                                 & 0 \leqslant \Constrainttle, \\
    \vec{r_0} + \frac{\vec{v_0} \left|\vec{v_0}\right|}{\left|\vec{a}\right|} + \frac{\vec{a} \left|\vec{v_0}\right|^2}{2 \left|\vec{a}\right|^2}, & \Constrainttge .
  \end{cases}
\end{equation}

Соответствующие проекции на ось абсцисс~(\ref{r_x_1}) и ординат~(\ref{r_y_1}):

\begin{equation}\label{r_x_1}
  x(t) =
  \begin{cases}
    x_0 + {v_0}_x t + \frac{a_x t^2}{2},                                                                                               & 0 \leqslant \Constrainttle, \\
    x_0 + \frac{{v_0}_x \left|\vec{v_0}\right|}{\left|\vec{a}\right|} + \frac{a_x \left|\vec{v_0}\right|^2}{2 \left|\vec{a}\right|^2}, & \Constrainttge.
  \end{cases}
\end{equation}

\begin{Underequation}
  \(x(t)\)~-- координата тела в момент времени \(t\) по оси \(X\);

  \(x_0\)~-- координата начального положения тела по оси \(X\).
\end{Underequation}

\begin{equation}\label{r_y_1}
  y(t) =
  \begin{cases}
    y_0 + {v_0}_y t + \frac{a_y t^2}{2},                                                                                               & 0 \leqslant \Constrainttle, \\
    y_0 + \frac{{v_0}_y \left|\vec{v_0}\right|}{\left|\vec{a}\right|} + \frac{a_y \left|\vec{v_0}\right|^2}{2 \left|\vec{a}\right|^2}, & \Constrainttge.
  \end{cases}
\end{equation}

\begin{Underequation}
  \(y(t)\)~-- координата тела в момент времени \(t\) по оси \(Y\);

  \(y_0\)~-- координата начального положения тела по оси \(Y\).
\end{Underequation}

% Формулы~(\ref{r_x_1}) и~(\ref{r_y_1}) являются ключевыми в этой работе.

\section{Определение уравнений для обнаружения столкновений}

Подставив формулы~(\ref{r_x_1}) и~(\ref{r_y_1}) в уравнения
(\ref{bodybodycollisioncoords}),~(\ref{bodypointcollisioncoords}),~(\ref{bodylinecolision})
можно получить алгебраические уравнения от \(t\) четвёртой степени.

Например, для случая, когда \(0 \leqslant \Constrainttle\) вывод уравнения времени столкновения тела с телом будет таким~(\ref{bodybodyoft}):

\begin{align}
  \sqrt{(x_1(t) - x_2(t))^2 + (y_1(t) - y_2(t))^2}        & = r_1 + r_2 \nonumber     \\
  (x_1(t) - x_2(t))^2 + (y_1(t) - y_2(t))^2               & = (r_1 + r_2)^2 \nonumber \\
  ({x_0}_1 + {{v_0}_x}_1 t + \frac{{a_x}_1 t^2}{2})^2
  - ({x_0}_2 + {{v_0}_x}_2 t + \frac{{a_x}_2 t^2}{2})^2 + & \nonumber                 \\
  + ({y_0}_1 + {{v_0}_y}_1 t + \frac{{a_y}_1 t^2}{2})^2
  - ({y_0}_2 + {{v_0}_y}_2 t + \frac{{a_y}_2 t^2}{2})^2   & = (r_1 + r_2)^2 \nonumber
\end{align}

\begin{align}\label{bodybodyoft}
  \frac{{a_x}_1^2 - {a_x}_2^2 + {a_y}_1^2 - {a_y}_2^2  }{4}                                                                    & t^4~+  \nonumber                        \\
  + ({{v_0}_x}_1 {a_x}_1 - {{v_0}_x}_2 {a_x}_2 + {{v_0}_y}_1 {a_y}_1 - {{v_0}_y}_2 {a_y}_2)                                    & t^3~+  \nonumber                        \\
  + ({x_0}_1 {a_x}_1 - {x_0}_2 {a_x}_2 + {y_0}_1 {a_y}_1 - {y_0}_2 {a_y}_2)                                                    & t^2~+  \nonumber                        \\
  + 2 ({x_0}_1 {{v_0}_x}_1 - {x_0}_2 {{v_0}_x}_2 + {y_0}_1 {{v_0}_y}_1 - {y_0}_2 {{v_0}_y}_2)                                  & t~+                                     \\
  \hspace{-1em}+ {{v_0}_x}_1^2 + {x_0}_1^2 - {{v_0}_x}_2^2 - {x_0}_2^2 + {{v_0}_y}_1^2 + {y_0}_1^2 - {{v_0}_y}_2^2 - {y_0}_2^2 & - r_1^2 - 2r_1 r_2 - r_2^2 = 0\nonumber
\end{align}

\begin{Underequation}
  \(x_1(t)\)~-- координата первого тела в момент времени \(t\) по оси \(X\);

  \(x_2(t)\)~-- координата второго тела в момент времени \(t\) по оси \(X\);

  \(y_1(t)\)~-- координата первого тела в момент времени \(t\) по оси \(Y\);

  \(y_2(t)\)~-- координата второго тела в момент времени \(t\) по оси \(Y\);

  \({x_0}_1\)~-- начальная координата первого тела по оси \(X\);

  \({x_0}_2\)~-- начальная координата второго тела по оси \(X\);

  \({y_0}_1\)~-- начальная координата первого тела по оси \(Y\);

  \({y_0}_2\)~-- начальная координата второго тела по оси \(Y\);

  \({{v_0}_x}_1\)~-- проекция вектора начальной скорости первого тела на ось \(X\);

  \({{v_0}_y}_1\)~-- проекция вектора начальной скорости первого тела на ось \(Y\);

  \({{v_0}_x}_2\)~-- проекция вектора начальной скорости второго тела на ось \(X\);

  \({{v_0}_y}_2\)~-- проекция вектора начальной скорости второго тела на ось \(Y\);

  \({a_x}_1\)~-- проекция вектора ускорения первого тела на ось \(X\);

  \({a_y}_1\)~-- проекция вектора ускорения первого тела на ось \(Y\);

  \({a_x}_2\)~-- проекция вектора ускорения второго тела на ось \(X\);

  \({a_y}_2\)~-- проекция вектора ускорения второго тела на ось \(Y\);

  \(r_1\)~-- радиус первого тела;

  \(r_2\)~-- радиус второго тела.
\end{Underequation}

Видно, что уравнение приняло вид~(\ref{polyequation}).

\begin{equation}\label{polyequation}
  P(t) = 0
\end{equation}

\begin{Underequation}
  \(P(t)\)~-- многочлен от \(t\).
\end{Underequation}

% Теперь найдём степень уравнения (т.е. максимальную степень одночлена).
% Возьмём одночлен \(\frac{{a_x}_1 t^2}{2}\), который является частью многочлена, который возведён в квадрат.
% Следовательно, в результирующем многочлене будет присутствовать одночлен~(\ref{monomial_1}).

% \begin{equation}\label{monomial_1}
%   (\frac{{a_x}_1 t^2}{2})^2 = \frac{{a_x}_1^2 t^4}{4}
% \end{equation}

% Как видно, в результирующем многочлене \(t\) возведён в 4 степень.
% При этом в результирующем уравнении этот одночлен не сократится
% потому что у других подобных одночленов другие коэффициенты.
% Значит, в результирующем уравнении будет присутствовать одночлен степени 4.

Значит, уравнение алгебраическое одной переменной. Его степень равна четырём.
При этом, для каждого случая подстановки формул~(\ref{r_x_1}) и~(\ref{r_y_1}) в уравнения
(\ref{bodybodycollisioncoords}),~(\ref{bodypointcollisioncoords}),~(\ref{bodylinecolision})
придётся производить 8 таких выводов
(для каждого из 2 случаев из~(\ref{r_x_1}) следует рассмотреть 2 случая из~(\ref{r_y_1}) при подстановке в~(\ref{bodybodycollisioncoords})
и по 2 случая при подстановке в~(\ref{bodypointcollisioncoords}) и~(\ref{bodylinecolision})),
проще составить программный алгоритм (который описан позднее в~\ref{expr}),
который применяя методы компьютерной алгебры, сможет строить выражения и вычислять их значения, подставляя переменные.

\section{Решение алгебраических уравнений четвёртой степени}\label{solvefourthdegree}

Так как для работы создаваемого физического движка не требуется обнаруживать время столкновения
без погрешности и корни могут быть только действительными, можно воспользоваться численными методами.
К тому же, аналитические методы решения алгебраических уравнений четвёртой степени обладают громоздкостью.
И при этом, предложенный далее метод численного решения алгебраических уравнений позволяет решать уравнения любой степени,
что позволит теоретически внести в модель и реализацию, без существенного переписывания кода, например разноускоренное движение
(т.е. величину рывок, от которой зависит ускорение) и тогда уравнение, подобное~(\ref{bodybodyoft}),
получится степени выше четвёртой, что не имеет решений в радикалах вовсе по теореме Абеля о неразрешимости уравнений в радикалах~\cite[с.~112]{alekseevabel}.

\subsection{Метод бисекции}\label{bisection}
Метод бисекции или метод деления отрезка пополам~-- простейший численный метод для решения нелинейных уравнений вида \(f(x)=0\),
является частным случаем бинарного поиска~\cite{bisectionkaw}.

Метод бисекции позволяет найти корень функции на отрезке \([x_l, x_r]\), если \(sign(f(x_l))\neq sign(f(x_r))\).
При этом, если функция \(f(x)\) не монотонна,
она имеет несколько корней и метод найдёт лишь один корень~\cite{bisectionkaw}.
Поэтому, метод бисекции не подходит для общего случая поиска решений алгебраических уравнений
без предварительной подготовки, которая описана в пункте~\ref{polynomialequation}.

При этом можно обобщить этот метод для поиска корней на промежутках вида \((-\infty, x_r]\), \([x_l, +\infty)\).
Недостающую границу поиска можно подобрать кратным (например, с каждой итерацией увеличивать изменение в 2 раза) увеличением (в случае бесконечности справа)
или уменьшением (в случае бесконечности слева) относительно известной границы до того момента, пока
знак функции на левой и правой границе не станет разным. Но при этом надо учесть, что корня на промежутке
может не быть в случае когда при изменении (увеличении или уменьшении, как указано ранее) неизвестной границы, значение функции не становится
ближе к нулю.

Описание метода: на каждой итерации берётся середина отрезка~(\ref{x_m}).

\begin{equation}\label{x_m}
  x_m = \frac{x_l + x_r}{2}
\end{equation}

\begin{Underequation}
  \(x_m\)~-- середина отрезка \([x_l, x_r]\).
\end{Underequation}

Теперь следует вычислить значение функции в середине отрезка и если~(\ref{fxmleeps}), то корень (равный \(x_m\)) найден;
иначе следует разбить отрезок \([x_l, x_r]\) на два отрезка \([x_l, x_m]\) и \([x_m, x_r]\).

\begin{equation}\label{fxmleeps}
  \left|f(x_m)\right| \leqslant \varepsilon
\end{equation}

\begin{Underequation}
  \(\varepsilon\)~-- заданная точность по оси \(Y\).
\end{Underequation}

Далее, если \(x_l\) и \(x_m\) имеют разный знак, провести итерацию с отрезком \([x_l, x_m]\).
Иначе, разный знак должен быть у  \(x_m\) и \(x_r\), значит провести итерацию с отрезком \([x_m, x_r]\).

\subsection{Описание реализованного метода}\label{polynomialequation}

Допустим, нам известны точки экстремума (т.е. локальные минимумы и максимумы) функции \(P(x)\).
Тогда, можно получить промежутки возрастания и убывания функции.
Если на концах этих промежутках функция принимает разный знак,
значит она имеет один корень и его можно найти методом бисекции, описанном в~\ref{bisection}.

Но как получить экстремумы функции? Т.к. возрастание меняется на убывание (или наоборот),
значит производная функции меняет знак и в точки экстремума имеет значение \(0\).
Значит, надо найти корни производной. Так как мы работает с многочленом, производная многочлена
имеет степень на единицу меньше. Поэтому можно применять рекурсивно применять этот же метод,
пока степень не уменьшиться до того как уравнение можно решить аналитическим методом,
например линейное или квадратное.

\section{Обработка ударов}

Формула расчёта скорости удара двух движущихся объектов на двухмерной плоскости в без-угловом виде
выглядит следующим образом~(\ref{collisionhandle}), согласно~\cite{wiki-ellastic-collision}:

\begin{equation}\label{collisionhandle}
  \vec{v_1^\prime} = \vec{v_1} - \frac{2 m_2}{m_1 + m_2}
  \frac{\langle \vec{v_1} - \vec{v_2}, \vec{r_1} - \vec{r_2} \rangle }{\left| \vec{r_1} - \vec{r_2} \right|^2}
  (\vec{r_1} - \vec{r_2})
\end{equation}

\begin{Underequation}
  \(\vec{v_1^\prime}\)~-- вектор скорости первого тела после удара;

  \(\vec{v_1}\)~-- вектор скорости первого тела до удара;

  \(\vec{v_2}\)~-- вектор скорости второго тела до удара;

  \(\vec{r_1}\)~-- радиус-вектор положения первого тела;

  \(\vec{r_2}\)~-- радиус-вектор положения второго тела;

  \(m_1\)~-- масса первого тела;

  \(m_2\)~-- масса второго тела.
\end{Underequation}

Для вычисление скорости второго тела, надо поменять местами нижние индексы, обозначающие первое и второе тело.

Эту же формулу можно и применить для обработки ударов с точками и линиями. Достаточно принять в бесконечность в качестве массы второго тела,
нулевой вектор в качестве скорости и точку соприкосновения в качестве радиус-вектора положения второго тела.

Для того чтобы найти точку соприкосновения тела и линии, надо опустить перпендикуляр из центра круга на прямую.
Для этого достаточно заметить, что коэффициенты при переменных в общем уравнении прямой,
образуют вектор, направленный перпендикулярно этой прямой. Тогда, вычислив вектор, направленный, как этот вектор, но
длиной, равной радиусу круга, можно получить вектор направленный из центра круга в искомую точку соприкосновения.
Искомую точку соприкосновения можно получить суммой найденного вектора и радиуса-вектора положения тела.
Итоговая формула~(\ref{straight-line-collision-point}).

\begin{equation}\label{straight-line-collision-point}
  \vec{p} = \vec{r} + \frac{\vec{AB}}{\left|\vec{AB}\right|} r
\end{equation}

\begin{Underequation}
  \(\vec{p}\)~-- радиус-вектор точки соприкосновения тела и линии;

  \(\vec{r}\)~-- радиус-вектор положения тела;

  \(r\)~-- радиус тела;

  \(\vec{AB}\)~-- вектор, направленный перпендикулярно линии (равный \((A, B)\)).
\end{Underequation}

\section{Процесс моделирования}\label{statemachine_1}

Модель можно реализовать как стейт-машину, которая принимает на вход
текущую модель и действие и возвращает новую модель. Действие может быть, например, таким:

\begin{itemize}
  \item придание скорости телу;
  \item добавление тела, или точки, или линии;
  \item удаление тела, или точки, или линии;
  \item изменение параметров тела;
  \item изменение глобальных параметров (ускорение свободного падения).
\end{itemize}

% TODO
% Подробности реализации описаны в пункте~\ref{engine}.
