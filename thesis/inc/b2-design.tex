\chapter{Проектирование}

\TODO

Кроме создания физического движка, важно продемонстрировать его работу.
Желательно в интерактивном режиме. В XXI веке сложилась ситуация, что веб-приложения
обладают преимуществом, таким что для того чтобы им воспользовался пользователь, достаточно
браузера и просто перейти по ссылке.
Поэтому, решено сделать Single Page Application [\TODO],
которое в интерактивном режиме отображает состояние модели, меняющееся с течением времени
в главе \TODO объяснено \TODO.

Так как создаваемый движок будет способен работать в реальном времени, существует возможность
создать многопользовательский режим, для которого потребуется серверная часть,
на которую перенесётся работа движка, а клиенты будут получать лишь изменения в модели (подробнее в \TODO).
Соответственно, браузерное интерактивное SPA приложение с графическим интерфейсом назовём клиентской часть.

Так как мы хотим, чтобы движок работал и на клиентской части, и на серверной, следует выбрать язык программирования,
который позволяет создавать и браузерные приложения, и нативные.

При этом для того чтобы сделать веб-приложение интерактивным, браузеры могут работать лишь с JavaScript
с возможность подключения WebAssembly-модулей [\TODO]. WebAssembly~-- относительно новый способ создавать
приложения на языке, отличным от JavaScript [\TODO]. Он представляет из себя байткод стековой машины,
который может быть получен из множества языков, например C/С++ [\TODO], Rust [\TODO], C\# [\TODO], F\# [\TODO].

Однако существует и другой способ
писать на языке отличном от JavaScript~-- это использования компилятора, который исходный код на нужном языке
компилирует в код на языке JavaScript, пригодный для исполнения в браузере. Поэтому существуют языки программирования,
пригодные для исполнения и в браузере, и на сервере, что приводит к переиспользованию кода и уменьшении времени разработки.
Примеры таких языков: TypeScript [\TODO], OCaml (подробнее в пункте \ref{jsoo}), F\# [\TODO].

При выборе языка программирования важно руководствоваться не только его кроссплатформенностью
(в данном случае кроссплатформенностью можно назвать возможность работать и в браузере, и на сервере),
но ещё и опытом работы с ним; стоит обратить внимание на выразительность, способность к обнаружению ошибок,
производительность, экосистему. В качестве такого языка программирования выбран OCaml.

\section{Язык программирования OCaml}

OCaml (до 2011 - Objective Caml \cite{camlhistory})~-- промышленный язык программирования общего назначения,
в котором особое внимание уделяется выразительности и надёжности \cite{ocamlorg}. Обладает
мультипарадигменностью, но в первую очередь преподноситься как функциональный язык программирования.

\TODO поправить список (абзацный отступ, буллет, интервал) \TODO

Ключевые достоинства и черты OCaml, согласно \cite[c.~3]{yaron2011} и \cite{rwo-prologue}:

\begin{itemize}
    \item \textbf{Выразительность}. на OCaml можно создавать более компактные, простые и понятные системы,
          чем на таких языках, как Java или C\#.
    \item \textbf{Обнаружение ошибок}. Cуществует удивительно
          широкий круг ошибок, против которых система типов эффективна, включая многие ошибки, которые довольно трудно
          обнаружить с помощью тестирования.
    \item \textbf{Производительность}. Производительность OCaml находится на одном уровне или лучше,
          чем у Java, и на расстоянии вытянутой руки от таких языков, как C или C++. В добавок к высококачественной генерации нативного кода,
          OCaml имеет инкрементальный сборщик мусора, который может быть настроен на выполнение небольших
          фрагментов работы за раз, что делает его более подходящим для приложений мягкого реального времени,
          таких как трейдинг.
    \item Сборка мусора для автоматического управления памятью, которая сейчас является общей чертой современных языков высокого уровня.
    \item Функции первого порядка, которые можно передавать как обычные значения, как в JavaScript, Common Lisp и C\#.
    \item Статическая типизация увеличивает производительность и уменьшает число ошибок во время исполнения, как в Java или C\#.
    \item Параметрический полиморфизм, позволяющий создавать абстракции, работающие с различными типами данных,
          подобно джереникам из Java, Rust, C\# или шаблонам из C++.
    \item Хорошая поддержка иммутабельного программирования, т.е. программирования без деструктивных обновлений в структурах данных.
          Такой подход представлен в традиционных функциональных языках программирования, таких как Scheme, а так же часто встречается
          во всём от распределенных фреймворков для работы с большими данными до UI-тулкитов.
    \item Вывод типов, который позволяет не указывать тип каждой переменной в программе.
          Вместо этого, типы выводятся из того, как используется значение. В мейнстримных языках
          такое есть на уровне локальных переменных, например ключевое слово <<var>> в C\# или ключевое слово <<auto>> в C++.
    \item Алгебраические типы данных и паттерн-матчинг позволяют определять и манипулировать сложными структурами данных.
          Так же доступны в Scala, Rust, F\#.

\end{itemize}

\section{Обзор экосистемы языка OCaml}

\TODO

\subsection{Компиляторы OCaml в JavaScript}\label{jsoo}

js\_of\_ocaml, rescript, ocamljs, (wasm \TODO) \TODO

\subsection{Стандартные библиотеки}

\TODO

ocaml: stdlib, base, core, containers, batteries,

rescipt: belt, tablecloth

\subsection{ML-синтаксис и Reason-синтаксис}

\TODO

\subsection{Библиотеки конкурентного программирования}

lwt, async, eio \TODO

При построении программ, взаимодействующих с внешним миром,
часто приходиться ожидать:
ожидать ответа от сервера,
ожидать нажатия на кнопку,

\subsection{Библиотеки для построения пользовательского интерфейса}

\TODO

js\_of\_ocaml: jsoo-react, ocaml-vdom, virtual\_dom, incr\_dom, bonsai

rescript: rescript-react, bucklescript-tea

\subsection{Библиотеки для RPC}

\TODO

\subsection{Web-фреймворки}

dream  \TODO

\subsection{Библиотеки для тестирования}

\TODO

\subsection{Библиотеки сериализации и десериализации}

\TODO

\textbf{Yojson}.

\textbf{Sexplib}.

\subsection{Среда разработки}

ocaml-lsp-server

\section{Прочие средства разработки}

\section{Выбор библиотек и подходов}

\TODO
